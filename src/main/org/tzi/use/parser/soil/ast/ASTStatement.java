/*
 * USE - UML based specification environment
 * Copyright (C) 1999-2010 Mark Richters, University of Bremen
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

// $Id$

package org.tzi.use.parser.soil.ast;

import static org.tzi.use.util.StringUtil.inQuotes;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;

import org.antlr.runtime.Token;
import org.tzi.use.parser.AST;
import org.tzi.use.parser.Context;
import org.tzi.use.parser.SemanticException;
import org.tzi.use.parser.SrcPos;
import org.tzi.use.parser.Symtable;
import org.tzi.use.parser.ocl.ASTExpression;
import org.tzi.use.parser.ocl.ASTType;
import org.tzi.use.uml.mm.MAssociation;
import org.tzi.use.uml.mm.MAssociationClass;
import org.tzi.use.uml.mm.MAssociationEnd;
import org.tzi.use.uml.mm.MAttribute;
import org.tzi.use.uml.mm.MClass;
import org.tzi.use.uml.mm.MOperation;
import org.tzi.use.uml.ocl.expr.Expression;
import org.tzi.use.uml.ocl.expr.VarDecl;
import org.tzi.use.uml.ocl.expr.VarDeclList;
import org.tzi.use.uml.ocl.type.ObjectType;
import org.tzi.use.uml.ocl.type.Type;
import org.tzi.use.uml.ocl.type.TypeFactory;
import org.tzi.use.uml.sys.soil.MRValue;
import org.tzi.use.uml.sys.soil.MStatement;
import org.tzi.use.util.StringUtil;
import org.tzi.use.util.soil.SymbolTable;
import org.tzi.use.util.soil.VariableSet;
import org.tzi.use.util.soil.exceptions.CompilationFailedException;


/**
 * Base class for objects of the abstract syntax tree
 * generated by ANTLR.
 * <p>
 * Holds references to the {@link Context} {@code fContext} and a special
 * {@link SymbolTable} {@code fSymbolTable}.
 * <p>
 * Furthermore each object of this kind posseses its own 
 * 
 * @author Daniel Gent
 *
 */
public abstract class ASTStatement extends AST {
	
	/**
	 * The source position of this statement
	 */
	private SrcPos fSourcePosition;
	
	/** TODO */
	private String fParsedText;
	
	private List<ASTStatement> fChildStatements = new ArrayList<ASTStatement>();
	
	/** TODO */
	protected VariableSet fBoundSet = new VariableSet();
	/** TODO */
	protected VariableSet fAssignedSet = new VariableSet();
	
	/** TODO */
	protected Context fContext;
	
	/** TODO */
	protected SymbolTable fSymtable;
	
	/** TODO */
	private Type fRequiredResultType;

	protected static boolean VERBOSE = false;
	
	protected static PrintWriter VERBOSE_OUT = new PrintWriter(System.out);

	
	/**
	 * Returns <code>true</code> if a source position is specified, i. e.,
	 * {@link #getSourcePosition()} does not return <code>null</code>. 
	 * @return
	 */
	public boolean hasSourcePosition() {
		return fSourcePosition != null;
	}
	
	
	/**
	 * Returns the source position of this statement id specified.
	 * Otherwise <code>null</code> is returned.
	 * @return The source position or <code>null</code>
	 */
	public SrcPos getSourcePosition() {
		return fSourcePosition;
	}
	
	
	/**
	 * Sets the source position of this statement.
	 * @param sourcePosition The source position to set
	 */
	public void setSourcePosition(SrcPos sourcePosition) {
		fSourcePosition = sourcePosition;
	}
	
	
	/**
	 *  Sets the source position of this statement to the position of the token.
	 * @param token A token which represents the position of this statement. 
	 */
	public void setSourcePosition(Token token) {
		setSourcePosition(new SrcPos(token));
	}

	/**
	 * TODO
	 * @param childStatement
	 */
	protected void addChildStatement(ASTStatement childStatement) {
		fChildStatements.add(childStatement);
	}
	
	
	/**
	 * TODO
	 * @param childStatements
	 */
	protected void addChildStatements(List<ASTStatement> childStatements) {
		fChildStatements.addAll(childStatements);
	}

	/**
	 * TODO
	 * @return
	 */
	public List<ASTStatement> getChildStatements() {
		return fChildStatements;
	}
	
	
	/**
	 * True if this statement is an instance of {@link ASTEmptyStatement}.
	 * @return <code>true</code> if this instance is an ASTEmptyStatement. 
	 */
	public boolean isEmptyStatement() {
		return (this instanceof ASTEmptyStatement);
	}
	
	
	/**
	 * TODO
	 * @return
	 */
	public SymbolTable getSymbolTable() {
		return fSymtable;
	}
	
	
	/**
	 * TODO
	 * @return
	 */
	public VariableSet bound() {
		return fBoundSet;
	}
	
	
	/**
	 * TODO
	 * @return
	 */
	public VariableSet assigned() {
		return fAssignedSet;
	}
	
	
	/**
	 * TODO
	 * @param name
	 * @return
	 */
	public boolean binds(String name) {
		return fBoundSet.contains(name);
	}
	
	
	/**
	 * TODO
	 * @param name
	 * @return
	 */
	public boolean assigns(String name) {
		return fAssignedSet.contains(name);
	}
		
	
	/**
	 * TODO
	 * @param type
	 */
	public void mustBindResultAs(Type type) {
		fRequiredResultType = type;
	}
	
	
	/**
	 * When set to <code>true</code> the <code>ASTStatement</code>s
	 * print more information to {@link PrintWriter} specified by {@link #setVerboseOutput(PrintWriter)}.
	 * @param verbose
	 */
	public static void setVerbose(boolean verbose) {
		VERBOSE = verbose;
	}
	
	/**
	 * Returns the state of verbose output.
	 * @return <code>true</code> if verbose output is enabled, <code>false</code> otherwise.
	 */
	public static boolean getVerbose() {
		return VERBOSE;
	}
	
	/**
	 * Sets the verbose output messages to <code>output</code>.
	 * @param output The PrintWriter for the verbose output.
	 */
	public static void setVerboseOutput(PrintWriter output) {
		VERBOSE_OUT = output;
	}
	
	/**
	 * Gets the current {@link PrintWriter} to output verbose messages to.
	 * @returns The current {@link PrintWriter} for verbose output.
	 */
	public static PrintWriter getVerboseOutput() {
		return VERBOSE_OUT;
	}
	
	/**
	 * TODO
	 * @param context
	 * @param symtable
	 * @return
	 * @throws CompilationFailedException
	 */
	public MStatement generateStatement(
			Context context,
			SymbolTable symtable) throws CompilationFailedException {
		
		fContext = context;
		fSymtable = symtable;
		
		verbosePrintln("generating " + this);
		
		MStatement result = generateStatement();

		result.setSourcePosition(fSourcePosition);
		
		if (fRequiredResultType != null) {
			if (!binds("result")) {
				throw new CompilationFailedException(this,
						"Operation must return a value, but variable "
								+ StringUtil.inQuotes("result")
								+ " might be unbound.");
			}
			
			Type resultType = bound().getType("result");
			if (!resultType.isSubtypeOf(fRequiredResultType)) {
				throw new CompilationFailedException(
						this, 
						"Operation returns a value of type " +
								StringUtil.inQuotes(resultType) +
								", which is not a subtype of the declared return type " +
								StringUtil.inQuotes(fRequiredResultType) +
								".");
			}
		}
		 
		return result;
	}
	
	
	/**
	 * TODO
	 * @param context
	 * @param operation
	 * @return
	 * @throws CompilationFailedException
	 */
	public MStatement generateStatement(
			Context context, 
			MOperation operation) throws CompilationFailedException {
		
		// build symbol table from ...
    	SymbolTable symbolTable = new SymbolTable();
    	// ... parameters and ...
    	for (VarDecl p : operation.allParams()) {
    		symbolTable.setType(p.name(), p.type());
    	}
    	// ... self
    	symbolTable.setType("self", TypeFactory.mkObjectType(operation.cls()));
    	
    	if (operation.hasResultType()) {
    		mustBindResultAs(operation.resultType());
    	}
    	
    	MStatement result = generateStatement(context, symbolTable);
    	result.setIsOperationBody(true);
    	
    	return result;
	}
	
	
	/**
	 * TODO
	 * @param indent
	 * @param indentInc
	 * @param errorOutput
	 */
	public void printTree(PrintWriter target) {
		printTree(new StringBuilder(), target);
	}
	
	
	@Override
	public String toString() {
		return fParsedText;
	}
	
	
	/**
	 * TODO
	 * @param prelude
	 * @param target
	 */
	protected abstract void printTree(
			StringBuilder prelude, 
			PrintWriter target);
	
	/**
	 * TODO
	 */
	public void flatten() {
		for (ASTStatement statement : fChildStatements) {
			statement.flatten();
		}
	}
	

	/**
	 * If isVerbose is set to <code>true</code> this method
	 * prints the string representation of <code>output</code> to
	 * the {@link PrintWriter} specified by {@link #setVerboseOutput(PrintWriter)}.
	 * @param output The object to print
	 */
	protected void verbosePrint(Object output) {
		if (VERBOSE) {
			VERBOSE_OUT.print(output);
			VERBOSE_OUT.flush();
		}
	}
	
	
	/**
	 * If isVerbose is set to <code>true</code> this method
	 * prints the string representation of <code>output</code> to
	 * the {@link PrintWriter} specified by {@link #setVerboseOutput(PrintWriter)} with an appended new line.
	 * @param output The object to print
	 */
	protected void verbosePrintln(Object output) {
		verbosePrint(output + "\n");
	}
	

	/**
	 * TODO
	 * @return
	 * @throws CompilationFailedException
	 */
	protected abstract MStatement generateStatement() throws CompilationFailedException;

	
	/**
	 * TODO
	 * @param expression
	 * @param context
	 * @param symbolTable
	 * @return
	 * @throws CompilationFailedException
	 */
	private Expression generateExpression(
			ASTExpression expression,
			Context context,
			SymbolTable symbolTable) throws CompilationFailedException {
	
		Set<String> freeVariables = expression.getFreeVariables();
		
		Symtable newSymtable = new Symtable();
		for (String name : freeVariables) {
			if (!symbolTable.contains(name)) {
				throw new CompilationFailedException(this, "Variable "
						+ StringUtil.inQuotes(name) + " in expression "
						+ StringUtil.inQuotes(expression.getStringRep())
						+ " is undefined.");
			}
			
			if (symbolTable.isDirty(name)) {
				ASTStatement cause = symbolTable.getCause(name);
				throw new CompilationFailedException(
						this, 
						"The type of variable " +
								StringUtil.inQuotes(name) +
								" in expression " +
								StringUtil.inQuotes(expression.getStringRep()) + 
								" is uncertain due to possible assignment in statement " +
								StringUtil.inQuotes(cause) +
								" at line " +
								cause.getSourcePosition().line() +
								", column " +
								cause.getSourcePosition().column() +
								"."
						);
			}
			
			try {
				newSymtable.add(name, symbolTable.getType(name), null);
			} catch (SemanticException e) {
				// reason for the caught exception is adding a variable with a name
				// that's already present. since we're adding the keys of a hashmap
				// to an empty Symtable this can't happen.
				// should this behavior change in the future, here's a hint to those
				// who broke it...
				throw new RuntimeException("unexpected exception", e);
			}
		}
		
		// if this statement gets parsed as part of an operation definition, we could
		// possibly break it by fiddling around with the symtable. so let's just make sure
		// the caller gets it back the way it was.
		Symtable backup = context.varTable();
		context.setVarTable(newSymtable);
		try {
			return expression.gen(context);
		} catch (SemanticException e) {
			throw new CompilationFailedException(
					this,
					"generation of expression " +
					StringUtil.inQuotes(expression.getStringRep()) +
							" failed, with following error:\n\n" +
							e.getMessage());
		} finally {
			context.setVarTable(backup);
		}
	}
	
	
	/**
	 * TODO
	 * @param expression
	 * @return
	 * @throws CompilationFailedException
	 */
	protected Expression generateExpression(
			ASTExpression expression) throws CompilationFailedException {
		
		return generateExpression(expression, fContext, fSymtable);
	}
	
	
	
	/**
	 * TODO
	 * @param expression
	 * @return
	 * @throws CompilationFailedException
	 */
	protected Expression generateObjectExpression(
			ASTExpression expression) throws CompilationFailedException {
		
		Expression possibleObject = generateExpression(expression);
		
		validateObjectType(possibleObject);
		
		return possibleObject;
	}
	
	
	/**
	 * TODO
	 * @param expression
	 * @return
	 * @throws CompilationFailedException
	 */
	protected Expression generateStringExpression(
			ASTExpression expression) throws CompilationFailedException {
		
		Expression possibleString = generateExpression(expression);
		
		if (!possibleString.type().isString()) {
			throw new CompilationFailedException(this, "Expression "
					+ inQuotes(expression.getStringRep()) + " is of type "
					+ inQuotes(possibleString.type()) + ", expected "
					+ inQuotes("String"));
		}
		
		return possibleString;
	}
	
	
	/**
	 * Gets the {@link MAttribute} of the class which is accessed by
	 * <code>objectExpr</code>.
	 * 
	 * @param objectExpr
	 *            Expression resulting in an object instance.
	 * @param attributeName
	 *            The name of the attribute to return.
	 * @return The attribute with <code>name</code> of the class of the
	 *         expression <code>objectExpr</code>.
	 * @throws CompilationFailedException
	 *             If the type of <code>objectExpr</code> is not an object type
	 *             or if the class has no attribute with the name
	 *             <code>attributeName</code>.
	 */
	protected MAttribute generateAttribute(
			Expression objectExpr, 
			String attributeName) throws CompilationFailedException {
		
		validateObjectType(objectExpr);
		
		MClass objectClass = ((ObjectType)objectExpr.type()).cls();
		MAttribute attribute = 
			objectClass.attribute(attributeName, true);
		
		if (attribute == null) {
			throw new CompilationFailedException(this, "Class "
					+ StringUtil.inQuotes(objectClass.name())
					+ " does not have an attribute "
					+ StringUtil.inQuotes(attributeName) + ".");
		}
		
		return attribute;
	}


	/**
	 * @param objectExpr
	 * @throws CompilationFailedException
	 */
	private void validateObjectType(Expression expression)
			throws CompilationFailedException {
		if (!expression.type().isObjectType()) {
			throw new CompilationFailedException(this,
					"Expected expression with object type, found type "
							+ StringUtil.inQuotes(expression.type()) + ".");
		}
	}
	
	
	/**
	 * TODO
	 * @param statement
	 * @return
	 * @throws CompilationFailedException 
	 */
	protected MStatement generateStatement(
			ASTStatement statement) throws CompilationFailedException {
		
		return statement.generateStatement(fContext, fSymtable);
	}
	
	
	/**
	 * TODO
	 * @param type
	 * @return
	 * @throws NotATypeException
	 */
	protected Type generateType(
			ASTType type) throws CompilationFailedException {

		try {
			return type.gen(fContext);
		} catch(SemanticException e) {
			throw new CompilationFailedException(this, "Expected type name, found " + StringUtil.inQuotes(type) + ".");
		}			
	}
	
	
	/**
	 * TODO
	 * @param type
	 * @return
	 * @throws CompilationFailedException
	 */
	protected MClass generateClass(
			ASTType type,
			boolean mayBeAssociationClass) throws CompilationFailedException {
		
		Type t = generateType(type);
		
		if (!t.isObjectType()) {
			throw new CompilationFailedException(this, "Expected object type, found "
					+ StringUtil.inQuotes(t) + ".");
		}
		
		MClass result = ((ObjectType)t).cls();
		
		if (!mayBeAssociationClass && 
				fContext.model().associations().contains(result)) {
			
			throw new CompilationFailedException(this,
					"Cannot instantiate association class "
							+ inQuotes(result.name())
							+ " without participants.");
		}
		
		return result;
	}
	
	
	/**
	 * TODO
	 * @param name
	 * @return
	 * @throws CompilationFailedException
	 */
	protected MAssociation getAssociation(
			String name) throws CompilationFailedException {
		
		MAssociation association = 
			fContext.model().getAssociation(name);
		
		if (association == null) {
			throw new CompilationFailedException(this, "Association "
					+ StringUtil.inQuotes(name) + " does not exist.");
		}
		
		return association;
	}
	
	
	/**
	 * TODO
	 * @param name
	 * @return
	 * @throws CompilationFailedException 
	 */
	protected MAssociationClass generateAssociationClass(
			String name) throws CompilationFailedException {
		
		MAssociationClass result =
            fContext.model().getAssociationClass(name);
		
		if (result == null) {
			throw new CompilationFailedException(this, "Association class "
					+ StringUtil.inQuotes(name) + " does not exist.");
		}
			
		return result;
	}
	
	
	/**
	 * TODO
	 * @param association
	 * @param participants
	 * @return
	 * @throws CompilationFailedException
	 */
	protected List<MRValue> generateAssociationParticipants(
			MAssociation association, 
			List<ASTRValue> participants) throws CompilationFailedException
	{
		
		List<MAssociationEnd> associationEnds = 
			association.associationEnds();
		
		int numParticipants = participants.size();
		int numAssociationEnds = associationEnds.size();
		
		if (numAssociationEnds != numParticipants) {
			throw new CompilationFailedException(this,
					"A link for association"
							+ ((association instanceof MAssociationClass) ? ""
									: " class")
							+ StringUtil.inQuotes(association) + " requires "
							+ numAssociationEnds + " objects, found "
							+ numParticipants + ".");
		}
		
		// generate the participant for each slot, and check
		// if their respective types are compatible
		List<MRValue> result = 
			new ArrayList<MRValue>(numParticipants);	
		
		for (int i = 0; i < numParticipants; ++i)	
		{
			MAssociationEnd associationEnd = 
				associationEnds.get(i);
			
			MRValue participant = 
				generateRValue(participants.get(i));
			
			Type expectedType = associationEnd.cls().type();
			Type foundType = participant.getType();
			
			if (!foundType.isSubtypeOf(expectedType)) {
				
				throw new CompilationFailedException(
						this, 
						"Participant " +  (i + 1) + " of association " + 
						((association instanceof MAssociationClass) ? "class " : "") +
						StringUtil.inQuotes(association.name()) +
						" must be of type " + StringUtil.inQuotes(expectedType) +
						", but " + StringUtil.inQuotes(participants.get(i)) +
						" is of type " + StringUtil.inQuotes(foundType) + ".");	
			}
			
			result.add(participant);
		}
		
		return result;
	}
	
	
	/**
	 * TODO
	 * @param object
	 * @param operationName
	 * @return
	 * @throws CompilationFailedException
	 */
	protected MOperation generateOperation(
			Expression object, 
			String operationName) throws CompilationFailedException {
		
		validateObjectType(object);
		
		MClass objectClass = ((ObjectType)object.type()).cls();
		
		return generateOperation(objectClass, operationName);
	}
	
	
	/**
	 * TODO
	 * @param objectClass
	 * @param operationName
	 * @return
	 * @throws CompilationFailedException
	 */
	protected MOperation generateOperation(
			MClass objectClass, 
			String operationName) throws CompilationFailedException {
		
		MOperation result = objectClass.operation(operationName, true);
		
		if (result == null) {
			throw new CompilationFailedException(this, "No operation "
					+ StringUtil.inQuotes(operationName) + "found in class "
					+ StringUtil.inQuotes(objectClass.name()) + ".");
		}
		
		return result;
	}
	
	
	/**
	 * TODO
	 * @param operation
	 * @param arguments
	 * @return
	 * @throws CompilationFailedException
	 */
	protected LinkedHashMap<String, Expression> generateOperationArguments(
			MOperation operation,
			List<ASTExpression> arguments) throws CompilationFailedException {
		
		VarDeclList parameters = operation.paramList();
		
		int numParameters = parameters.size();
		int numArguments = arguments.size();
		
		if (numParameters != numArguments) {
			throw new CompilationFailedException(this,
					"Number of arguments does not match declaration of operation"
							+ StringUtil.inQuotes(operation.name())
							+ ". Expected " + operation.paramList().size()
							+ " argument"
							+ ((operation.paramList().size() == 1) ? "" : "s")
							+ ", found " + arguments.size() + ".");
		}
		
		LinkedHashMap<String, Expression> result = 
			new LinkedHashMap<String, Expression>(arguments.size());
		
		for (int i = 0; i < numParameters; ++i) {
			
			VarDecl parameter = parameters.varDecl(i);
			Expression argument = generateExpression(arguments.get(i));
			
			Type expectedType = parameter.type();
			Type foundType = argument.type();
			
			if (!foundType.isSubtypeOf(expectedType)) {
				
				throw new CompilationFailedException(
						this,
						"Type mismatch in argument " + i + ". Expected type " +
						StringUtil.inQuotes(expectedType) + 
						", found " +
						StringUtil.inQuotes(foundType) + ".");
			}
			
			result.put(parameter.name(), argument);
		}
		
		return result;
	}
	
	
	/**
	 * TODO
	 * @param rValue
	 * @return
	 * @throws CompilationFailedException
	 */
	protected MRValue generateRValue(
			ASTRValue rValue) throws CompilationFailedException {
		
		return rValue.generate(this);
	}
}